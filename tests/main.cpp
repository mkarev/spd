/* The MIT License (MIT)
 *
 * Copyright (c) 2019 Mikhail Karev
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#include <spd.h>

#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>

/* How to get i2c dump:
    $ sudo modprobe i2c-dev
    $ sudo modprobe i2c-i801
    $ sudo i2cdetect -l
    ...
    i2c-0   smbus           SMBus I801 adapter at f040              SMBus adapter
    ...
    $ sudo i2cdetect 0
    ...
    50: 50 -- 52 -- -- -- -- -- -- -- -- -- -- -- -- --
    ...
    $ sudo i2cdump 0 0x52 b
*/
static const char i2cdump[] =
    "     0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f    0123456789abcdef\n"
    "00: 92 11 0b 03 04 21 00 09 03 11 01 08 0a 00 fe 00    ?????!.??????.?.\n"
    "10: 69 78 69 30 69 11 18 81 20 08 3c 3c 00 f0 83 05    ixi0i??? ?<<.???\n"
    "20: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................\n"
    "30: 00 00 00 00 00 00 00 00 00 00 00 00 0f 11 05 00    ............???.\n"
    "40: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................\n"
    "50: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................\n"
    "60: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................\n"
    "70: 00 00 00 00 00 07 5d 00 19 19 00 00 00 00 4c ee    .....?].??....L?\n"
    "80: 47 52 31 36 30 30 53 33 36 34 4c 31 31 2f 38 47    GR1600S364L11/8G\n"
    "90: 00 00 01 01 00 00 ff ff 4a aa 00 00 0c 23 09 02    ..??....J?..?#??\n"
    "a0: 00 00 00 bc 00 00 00 00 00 00 00 00 00 00 00 00    ...?............\n"
    "b0: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff    ................\n"
    "c0: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff    ................\n"
    "d0: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff    ................\n"
    "e0: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff    ................\n"
    "f0: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff    ................";

static const uint8_t spd_data[SPD_SIZE_MAX] = {
    0x92, 0x11, 0x0b, 0x03, 0x04, 0x21, 0x00, 0x09, 0x03, 0x11, 0x01, 0x08, 0x0a, 0x00, 0xfe, 0x00,
    0x69, 0x78, 0x69, 0x30, 0x69, 0x11, 0x18, 0x81, 0x20, 0x08, 0x3c, 0x3c, 0x00, 0xf0, 0x83, 0x05,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x11, 0x05, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x5d, 0x00, 0x19, 0x19, 0x00, 0x00, 0x00, 0x00, 0x4c, 0xee,
    0x47, 0x52, 0x31, 0x36, 0x30, 0x30, 0x53, 0x33, 0x36, 0x34, 0x4c, 0x31, 0x31, 0x2f, 0x38, 0x47,
    0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0xff, 0xff, 0x4a, 0xaa, 0x00, 0x00, 0x0c, 0x23, 0x09, 0x02,
    0x00, 0x00, 0x00, 0xbc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
};

int main (int argc, char *argv[])
{
    uint8_t data[SPD_SIZE_MAX];
    spd_read_i2cdump(data, i2cdump);
    if (memcmp(data, spd_data, sizeof(data))) {
        printf("spd_read_i2cdump() failed\n");
        exit(EXIT_FAILURE);
    }

    SpdInfo i;
    if (!spd_decode(&i, spd_data)) {
        printf("spd_decode() failed\n");
        exit(EXIT_FAILURE);
    }
    spd_print(&i, false);

    printf("OK");
    return EXIT_SUCCESS;
}
